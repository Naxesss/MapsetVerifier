using System;
using System.Collections.Generic;

namespace MapsetVerifier.Checks.Utils;

public static class GeneralUtils
{
    /// <summary>
    ///     Returns whether the number is within the given range of the target value.
    /// </summary>
    /// <param name="num">The number to check.</param>
    /// <param name="range">The range tolerance.</param>
    /// <param name="of">The target value to check against.</param>
    /// <returns>True if the number is within the range, otherwise false.</returns>
    public static bool IsWithin(this double num, double range, double of)
        => num <= of + range && num >= of - range;

    /// <summary>
    ///     Adds a range of keys to the dictionary with the specified value.
    /// </summary>
    /// <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of values in the dictionary.</typeparam>
    /// <param name="dictionary">The dictionary to add keys to.</param>
    /// <param name="keys">The collection of keys to add.</param>
    /// <param name="value">The value to associate with all keys.</param>
    public static void AddRange<TKey, TValue>(this Dictionary<TKey, TValue> dictionary, IEnumerable<TKey> keys, TValue value) where TKey : notnull
    {
        foreach (var key in keys)
            dictionary.Add(key, value);
    }

    /// <summary>
    ///     Adds a range of keys to the dictionary with values generated by the factory function.
    /// </summary>
    /// <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of values in the dictionary.</typeparam>
    /// <param name="dictionary">The dictionary to add keys to.</param>
    /// <param name="keys">The collection of keys to add.</param>
    /// <param name="valueFactory">The factory function to generate values for each key.</param>
    public static void AddRange<TKey, TValue>(this Dictionary<TKey, TValue> dictionary, IEnumerable<TKey> keys, Func<TValue> valueFactory) where TKey : notnull
    {
        foreach (var key in keys)
            dictionary.Add(key, valueFactory());
    }

    /// <summary>
    ///     Safely gets the element at the specified index, returning the default value if the index is out of range.
    /// </summary>
    /// <typeparam name="T">The type of elements in the collection.</typeparam>
    /// <param name="collection">The collection to get the element from.</param>
    /// <param name="index">The zero-based index of the element to get.</param>
    /// <returns>The element at the specified index, or the default value if the index is out of range.</returns>
    public static T SafeGetIndex<T>(this List<T> collection, int index)
        => index >= 0 && index < collection.Count ? collection[index] : default!;

    /// <summary>
    ///     Returns the value with the lower absolute value between two values.
    /// </summary>
    /// <param name="first">The first value to compare.</param>
    /// <param name="second">The second value to compare.</param>
    /// <returns>The value with the lower absolute value.</returns>
    public static double TakeLowerAbsValue(double first, double second)
    {
        return Math.Min(Math.Abs(first), Math.Abs(second));
    }

    /// <summary>
    ///     Returns the value with the higher absolute value between two values.
    /// </summary>
    /// <param name="first">The first value to compare.</param>
    /// <param name="second">The second value to compare.</param>
    /// <returns>The value with the higher absolute value.</returns>
    public static double TakeHigherAbsValue(double first, double second)
    {
        return Math.Max(Math.Abs(first), Math.Abs(second));
    }
}